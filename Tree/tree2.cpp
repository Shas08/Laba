#include <iostream>

using namespace std;

class Node  //класс узел
{
    int key, balance;        //Значение ключа узла и баланс
    Node *left, *right; //Указатели на левого и правого потомков
    public:
        friend class Tree;  //Т.к. класс дерево постоянно работает с узлами, то мы должны дать доступ к приватным член-данным класса узел
        friend class B_Tree;
        Node(int k=0, int b=0, Node *l=NULL, Node *r=NULL);  //Конструктор по умолчанию
        friend ostream& operator << (ostream &d, Node *e)//перегрузка оператора вывод
        {
            if(e==NULL) cout<<"Такого узла нет";
            else cout<<e->key;//вывод значения ключа
            return d;
        }

};

Node::Node(int k, int b, Node *l, Node *r) //определение конструктора по умолчанию
{
    key=k;
    balance=b;
    left=l;
    right=r;
}

class Tree //класс Дерево
{
    Node *root; //указатель на корень
    public:
    friend class B_Tree;//Дружественный класс сбалансированное дерево
    Tree(Node *p=NULL); //конструктор по умолчанию
    Tree(int *a, int n); //конструктор с двумя параметрами
    Tree(Tree &); //конструктор копирования
    ~Tree(); //деструктор
    int inarray(int *a); //упорядоченное заполнение массива
    void inarray_r(Node *p, int *a, int &k); //использование обхода Л-К-П для заполнения упорядоченного массива
    void levels(Node *t, int i); //Обход по уровням
    void levels(); //функция, которая передаёт высоту дерева для дальнейшего обхода по уровням
    int Height(); //функция, для использования корня дерева, как первого узла для вычисления высоты дерева
    int Height_node(Node *p); //вычисление высоты узла
    Tree operator =(Tree &t2); //перегрузка оператора присвоения
    int simple_node();
    void simple_node(Node *p, int &k);
    Tree create(int n); //функция для создания дерева вручную 
    Tree add_node(int k); //функция, для использования корня дерева, в качестве узла, куда возвращаются данные о других узлах после добавления
                          //очередного узла в дерево
    Node* add_node(Node *p, int k); //добавление узла в дерево
    Node* find_node(int k); //функция для нахождения узла в дереве
    Node* find_node(Node *p, int k); //продолжение ф-ции нахождения узла в дереве
    Tree del_node(int k); //удаление узла из дерева
    Node* del_node(Node *p); //продолжение удаления узла из дерева
    Node* min(); //нахождение минимума
    Node* max(); //нахождение максимума
    void copy(Node *rt, Node *&root);
    void clear(Node *rt);
    Node* find_root();
    void PrintV(int l, Node *p);
};

Node* Tree::find_root()
{
    return root;
}

Tree::Tree(Node *p) //конструктор по умолчанию
{
    root=p;
}

Tree::Tree(int *a, int n) //конструктор с двумя параметрами, где а-массив элементов, n-кол-во элементов
{
    root=NULL;
    for (int i=0; i<n; i++)//по циклу добавляем элементы с помощью функции добавления узла в дерево
    {
        root=add_node(root, a[i]);
    }
}

Tree::Tree(Tree &t2) //конструктор копирования
{
    copy(t2.root, this->root);
}

void Tree::clear(Node *rt)
{
    if(rt==NULL) return;
    clear(rt->left);
    clear(rt->right);
    delete rt;
    rt=NULL;
}

Tree::~Tree() //деструктор
{
    clear(root);
}

int Tree::Height() //ф-ция вычисления высоты дерева
{ 
    return Height_node(root);
}

int Tree::Height_node(Node *p) //ф-ция вычисления высоты узла
{ 
    if(p == NULL) return 0; //у пустых деревьев и узлов соответствующая высота
    int h_l = Height_node(p -> left); //в высоту левого поддерева заносим рекурсией значение высоты левого потомка
    int h_r = Height_node(p -> right); //в высоту правого поддерева заносим рекурсией значение высоты правого потомка
    if(h_l > h_r) return h_l + 1; //Если высота левого потомка больше правого, то высота корня данного поддерева соответственно на 1 больше
    return h_r + 1; //Иначе высота корня данного поддерева больше высоты правого поддерева на 1
}

void Tree::PrintV(int l, Node *p)
{
    if(p == NULL) return;
    PrintV(l + 3, p->right);
    for(int k = 0; k < l; k++) cout<<" ";
    cout.width(2);
    cout<<p->key<<"\n";
    PrintV(l + 3, p->left);
}

void Tree::levels() //Передаём высоту дерева в качестве параметра в ф-цию обхода по уровням
{
    int u=Height();
    for(int i=0; i<u; i++) //по циклу обходим дерево u раз
    {
        levels(root, i);//передаём какой уровень нужно вывести
        cout<<endl;// отступаем
    }
}

void Tree::levels(Node *t, int i) //ф-ция нахождения нужного уровня
{
    if (t==NULL) return; //Если узел пустой, возвращаемся
    else
    {
        if(i==0) //если u=0, то мы дошли до нужного уровня, выводим элемент
        {
            cout<<t->key<<"  ";
            return;
        }
        if(t->left) levels(t->left, i - 1); //рекурсией уходим влево и уменьшаем число уровней, которое осталось пройти до нужного
        if(t->right) levels(t->right, i - 1); //рекурсией уходим вправо и уменьшаем число уровней, которое осталось пройти до нужного
    }
}

int Tree::inarray(int *a) //передаём пустой массив размера n и возвращаем число узлов в дереве
                          //(оно может отличаться от изначального, путём добавления/удаления элементов)
{
    int k=0; //обнуляем счётчик
    inarray_r(root, a, k); //вызываем основную функцию заполнения упорядоченного массива
    return k; //возвращаем число элементов в массиве
}

void Tree::inarray_r(Node *p, int *a, int &k)// заполняем массив
{
    if(p==NULL) return;//если узел пуст, добавлять нечего, возвращаемся
    inarray_r(p->left, a, k);//рекурсивно уходим влево, пока не дойдём до конца
    a[k]=p->key;//заносим в массив значение ключа
    k++; //увеличиваем счётчик элементов
    inarray_r(p->right, a, k);//рекурсивно уходим вправо и продолжаем таким образом обход Л-К-П
}

Tree Tree::operator =(Tree &t2)// оператор присвоения
{
    if(this==&t2) return *this;
    else
    {
        clear(this->root);
        copy(t2.root, this->root);
        return *this;
    }
}

void Tree::copy(Node *rt, Node *&root)
{
    if(rt!=NULL)
    {
        root=new Node;
        root->key=rt->key;
        root->left=NULL;
        root->right=NULL;
        copy(rt->left, root->left);
        copy(rt->right, root->right);
    }
}

Tree Tree::create(int n)//ф-ция создания дерева
{
    int k;//вводимые с клавиатуры значения ключей
    cout<<"Введите элементы"<<endl;
    for(int i=0; i<n; i++)
    {
        cin>>k;
        root=add_node(root, k);//добавление узлов в дерево
    }
    return *this;//возвращение конечного дерева
}

Tree Tree::add_node(int k)//добавления узла в дерево
{
    root=add_node(root, k);//возвращает корень с изменённой информацией о потомках и т.д.
    return *this;//возвращает конечное дерево
}

Node* Tree::add_node(Node *p, int k)//ф-ция добавления узла в дерево
{
    if(p==NULL) //Если узел пуст, то добавляем наш узел в это место
    {
        Node *p=new Node(k);//создаём узел, используя конструктор по умолчанию(к-значение ключа нашего узла)
        return p;//возвращаем узел
    }
    if(k<=p->key) p->left=add_node(p->left, k);//Если значение добавляемого узла меньше либо равно текущему, рекурсивно уходим в левое поддерево
    else p->right=add_node(p->right, k);//Иначе если значение добавляемого узла больше текущего, рекурсивно уходим в правое поддерево
    return p;//возвращаем узел
}

Node* Tree::find_node(int k)//ф-ция нахождения узла
{
    Node *p=find_node(root, k);//возвращаем нужный узел, либо NULL
    return p;//возвращаем узел
}

Node* Tree::find_node(Node *p, int k)//ф-ция нахождения узла
{
    if(p==NULL) return p;//если узел пуст, возвращаемся 
    if(k==p->key) return p;//если искомое значение совпадает с ключём текущего узла, мы нашли его, возвращаем его
    if(k<p->key) p=find_node(p->left, k);//Если искомое значение меньше ключа текущего узла, идём в левое поддерево
    else if(k>p->key) p=find_node(p->right, k);//Иначе в правое поддерево
    return p;//возвращаем результат поисков
}

Tree Tree::del_node(int k)//ф-ция удаления узла
{
    Node *q=find_node(k), *f=root;//Ищем узел в дереве 
    if (q==NULL) return *this;//Если мы не находим его, значит удалять нечего, возвращаем текущее дерево
    if(q==root)//если удаляемый узел это корень, удаляем корень и на его месть возвращаем результат ф-ции удаления узла из дерева
    {
        root=del_node(q);
        return *this;//возвращаем новое дерево
    }
    while((f->left!=q) && (f->right!=q))//пока мы не найдём путь от корня до удаляемого узла:
    {
        if(f->key>q->key)f=f->left;//Если значение текущего узла больше нужного узла, двигаемся влево
        else f=f->right; //Иначе вправо
    }
    if (f->left==q) f->left=del_node(q);//Если левый потомок текущего узла = нужному, в левого потомка возвращаем результат удаления узла q
    else f->right=del_node(q);//иначе, в правого потомка
    return *this;//возвращаем новое дерево
}

Node* Tree::del_node(Node *q)//удаление узла из дерева
{
    Node *s, *r;//s будет потомком текущего узла, r-предком
    if(q->left==NULL && q->right==NULL)//Если у удаляемого узла нет потомков, просто опустошаем его
    {
        delete q;
        q=NULL;
        return q;
    }
    if(q->right==NULL)//если он не имеет правого потомка, то на его место становится его левый потомок
    {
        r=q;
        q=q->left;
        delete r;
        return q;
    }
    if(q->left==NULL)//если он не имеет левого потомка, то на его место становится его правый потомок
    {
        r=q;
        q=q->right;
        delete r;
        return q;
    }
    //Если есть и левый и правый потомок, выбираем ближайший по значению узел из правого поддерева
    s=q->right;
    if(s->left==NULL)//Если у правого потомка удаляемого узла нет левого потомка, значит правый потомок наименьший из этого поддерева
    {
        q->key=s->key;//Не использую присвоение, т.к. сотрутся данные о левом поддереве удаляемого узла, а это недопустимо
        q->right=s->right;
        delete s;//очищаю память s
        return q;
    }
    while(s->left!=NULL)//Если левый потомок правого поддерева удаляемого узла не пуст, идём налево доконца, т.к. последний будет наименьшим по значению
    {
        r=s; s=s->left;//r-предок s
    }
    q->key=s->key;//переназначаем новый узел на место удалённого
    r->left=s->right;
    delete s;//очищаем память
    return q;
}

Node* Tree::min()//минимум
{ 
    if(root==NULL) cout << "Дерево пустое";//Если корень пуст->дерево пусто
    Node *p=root;
    while(p->left) p=p->left;//уходим влево до конца дерева, там находится минимальный элемент
    return p;
}

Node* Tree::max()//максимум
{ 
    if(root==NULL) cout << "Дерево пустое";//Если корень пуст->дерево пусто
    Node *p=root;
    while(p->right) p=p->right;//уходим вправо до конца дерева, там находится максимальный элемент
    return p;
}

int Tree::simple_node()
{
    int k=0;
    simple_node(root, k);
    return k;
}

void Tree::simple_node(Node *p, int &k)
{
    if(p==NULL) return;//если узел пуст, возвращаем прежднее число
    simple_node(p->left, k);//рекурсивно уходим влево, пока не дойдём до конца
    int t=1;//счётчик чисел которые делят наш текущий ключ
    for(int i=2; i<p->key; i++)
        if(p->key%i==0)
        {
            t++;
            break;//Т.к ключ делится на число меньшее его и не равное 1, оно не простое
        }
    if(t==1) k++;//t-число делителей (невключая 1)
    simple_node(p->right, k);//рекурсивно уходим вправо и продолжаем таким образом обход Л-К-П
}

class B_Tree: public Tree // на 5: построение дерева поиска на основе добавления узла с балансировкой
{
    public:
    int balance(Node *p); //вычисление баланса узла
    B_Tree create_with_balance(int n);//функция для создания дерева вручную на основе балансировки 
    B_Tree add_node_with_balance(int k); //аналогично предыдущей функции, но на основе балансировки
    Node* add_node_with_balance(Node *p, int k, bool &h);//добавление узла в дерево на основе балансировки
};

int B_Tree::balance(Node *p) //ф-ция вычисления баланаса узла
{
    int h_l=Height_node(p->left); //вычисляем высоту левого поддерева
    int h_r=Height_node(p->right); //вычисляем высоту правого поддерева
    return (h_r - h_l); //возвращаем разность от высоты правого поддерева высоту левого поддерева
}

B_Tree B_Tree::create_with_balance(int n) //аналогично ф-ции создания мы создаём дерево, но учитываем балансировку
{
    int k; //вводимые с клавиатуры значения
    bool h; //булева переменная, которая будет определять, нужно ли проводить пересчёт баланса у предков
    cout<<"Введите элементы"<<endl;
    for(int i=0; i<n; i++)
    {
        cin>>k;
        h=true;//изначально она true, т.к. при добавлении узла лишь при определённых условиях баланс пересчитывать не нужно
        root=add_node_with_balance(root, k, h);//добавляем узлы в дерево
    }
    return *this;//возвращаем конечное сбалансированное дерево
}

B_Tree B_Tree::add_node_with_balance(int k) //добавление узла на основе балансировки в уже созданное (СБАЛАНСИРОВАННОЕ!) дерево
{
    bool h=true; //изначально она true, т.к. при добавлении узла лишь при определённых условиях баланс пересчитывать не нужно
    root=add_node_with_balance(root, k, h);//добавляем узлы в дерево
    return *this;//возвращаем конечное дерево
}

Node* B_Tree::add_node_with_balance(Node *p, int k, bool &h) //добавление узла на основе балансировки
{
    Node *s, *r; //создаём 2 узла(на случай, если потребуются однократный или двукратный повороты) 
    if(p==NULL)//Если узел пуст, то добавляем наш узел в это место
    {
        Node *p=new Node(k);//создаём узел, используя конструктор по умолчанию(к-значение ключа нашего узла)
        return p;//возвращаем узел
    }
    if(k<=p->key)//Если значение добавляемого узла меньше либо равно текущему, рекурсивно уходим в левое поддерево
    {
        p->left=add_node_with_balance(p->left, k, h);//рекурсивное добавление узла в левое поддерево и последующее возвращение информации о потомках 
                                                     //в левого потомка текущего узла
        if(h==false) return p;// если h=false, значит пересчёт баланса у предков не нужен, возвращаемся
        else//иначе
        {
            if(p->balance==1)//Если баланс текущего узла был 1, значит до добавления у правого поддерева высота была больше, чем у левого на 1
            {
                p->balance=0;//После добавления узла в левое поддерево текушего узла,
                             //высота левого поддерева увеличилась на 1 и баланс текущего узла уменьшился на 1
                h=false;//т.к баланс текушего узла стал равен 0, а до добавления узла был равен 1, значит баланс предка не изменился и т.д,
                        //тогда пересчитывать не нужно
                return p;//возвращаем узел
            }
            if(p->balance==0)//Если баланс текущего узла был 0, значит до добавления узла высоты левого и правого поддеревьев были равны
            {
                p->balance=-1;//После добавления узла в левое поддерево текушего узла,
                             //высота левого поддерева увеличилась на 1 и баланс текущего узла уменьшился на 1
                return p;//возвращаем узел
            }
            if(p->balance==-1)//Если баланс текущего узла был -1, значит до добавления у правого поддерева высота была меньше, чем у левого на 1
            {
                p->balance=-2;//После добавления узла в левое поддерево текушего узла,
                             //высота левого поддерева увеличилась на 1 и баланс текущего узла уменьшился на 1
                s=p->left;//пусть узел s будет левым потомком текущего узла
                if(s->balance==-1)//если его баланс одного знака с балансом предка, делаем однократный поворот направо
                {
                    p->left=s->right;//правый потомок s становится левым потомком p
                    s->right=p;//А сам p становится правым потомком s
                    p->balance=0;// балансы обнуляются, т.к. высоты поддеревьев становятся равны
                    s->balance=0;
                    p=s;//переименуем, чтобы вернуть узел заменивший предыдущий
                }
                else if(s->balance==1)//Иначе, если его баланс противоположного знака с балансом предка, делаем однократный поворот налево, а затем
                                      //однократный поворот направо
                {
                    r=s->right;//делаем однократный поворот налево через s, где r-правый потомок s, чтобы сделать баланс s одного знака с балансом p
                    s->right=r->left;
                    r->left=s;
                    p->left=r->right;//делаем однократный поворот направо через p, чтобы сделать поддерево сбалансированным
                    r->right=p;
                    if(r->balance==-1)//Если баланс r =-1, то после поворотов баланс p увеличится на 2, а у s уменьшится на 1
                    {
                        p->balance=1;
                        s->balance=0;
                    }
                    if(r->balance==1)//Если же баланс r =1, то после поворотов баланс p увеличится на 1, а у s уменьшится на 2
                    {
                        p->balance=0;
                        s->balance=-1;
                    }
                    if(r->balance==0) p->balance=s->balance=0;//если баланс r =0, где r на данный момент предок s и p, то после поворотов балансы s и p =0
                    r->balance=0; //При любом условии баланс r обнуляем и переобозначаем p на r, чтобы вернуть узел заменивший предыдущий
                    p=r;
                }
                h=false;//т.к баланс текушего узла стал равен 0, а до добавления узла был равен -1, значит баланс предка не изменился и т.д,
                        //тогда пересчитывать не нужно 
                return p;
            }
        }
    }
    else //Иначе, если значение добавляемого узла больше текущего, рекурсивно уходим в правое поддерево
    {
        p->right=add_node_with_balance(p->right, k, h); //рекурсивное добавление узла в правое поддерево и последующее возвращение информации о потомках 
                                                     //в правого потомка текущего узла
        if(h==false) return p;// если h=false, значит пересчёт баланса у предков не нужен, возвращаемся
        else//Иначе
        {
            if(p->balance==-1)//Если баланс текущего узла был -1, значит до добавления у правого поддерева высота была меньше, чем у левого на 1
            {
                p->balance=0;//После добавления узла в правое поддерево текушего узла,
                             //высота правого поддерева увеличилась на 1 и баланс текущего узла увеличился на 1
                h=false;//т.к баланс текушего узла стал равен 0, а до добавления узла был равен -1, значит баланс предка не изменился и т.д,
                        //тогда пересчитывать не нужно
                return p;
            }
            if(p->balance==0)//Если баланс текущего узла был 0, значит до добавления узла высоты левого и правого поддеревьев были равны
            {
                p->balance=1;//После добавления узла в правое поддерево текушего узла,
                             //высота правого поддерева увеличилась на 1 и баланс текущего узла увеличился на 1
                return p;//возвращаем узел
            }
            if(p->balance==1)//Если баланс текущего узла был 1, значит до добавления у правого поддерева высота была больше, чем у левого на 1
            {
                p->balance=2;//После добавления узла в правое поддерево текушего узла,
                             //высота правого поддерева увеличилась на 1 и баланс текущего узла увеличился на 1
                s=p->right;//пусть узел s будет правым потомком текущего узла
                if(s->balance==1)//если его баланс одного знака с балансом предка, делаем однократный поворот налево
                {
                    p->right=s->left;//правый потомок текущего узла становится левым потомком s
                    s->left=p;//А левым потомком s в свою очередь становится p
                    p->balance=0;//балансы обнуляются
                    s->balance=0;
                    p=s;//переименуем для возвращения узла, заменившего предыдущий
                }
                else if(s->balance==-1)//Иначе, если его баланс противоположного знака с балансом предка, делаем однократный поворот направо, а затем
                                      //однократный поворот налево
                {
                    r=s->left;          //В общем, аналогично как если бы выходили из левой рекурсии, только зеркально всё...
                    s->left=r->right;
                    r->right=s;
                    p->right=r->left;
                    r->left=p;
                    if(r->balance==1)
                    {
                        p->balance=-1;
                        s->balance=0;
                    }
                    if(r->balance==-1)
                    {
                        p->balance=0;
                        s->balance=1;
                    }
                    if(r->balance==0) p->balance=s->balance=0;
                    r->balance=0;
                    p=r;
                }
                h=false;
                return p;
            }
        }
    }
    return p;
}

int main()// Здесь проходили некоторые проверки и т.д
{
    B_Tree t1;
    Node *root;
    int n;
    cout<<"kol-vo vershin"<<endl;
    cin>>n;
    t1.create_with_balance(n);
    root = t1.find_root();
    t1.PrintV(0, root);
    return 0;
}